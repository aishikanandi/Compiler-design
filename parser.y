%{ 
   /* Definition section */
  #include<stdio.h> 
  #include<stdlib.h>
  #include "y.tab.h"
  int flag=0;
  extern int yylex();
extern void yyerror(const char*);
extern char* yytext;
extern int yyget_lineno(void);
 
%}

%start input
%token TOKEN_KEYWORD TOKEN_PSEUDOKEYWORD TOKEN_AWAIT TOKEN_NULL TOKEN_BIN_OPERATOR TOKEN_VARIABLE TOKEN_CONST TOKEN_LET TOKEN_SMCLN TOKEN_EQUAL TOKEN_NOT TOKEN_LC TOKEN_RC TOKEN_WHILE TOKEN_DO TOKEN_FOR TOKEN_IF TOKEN_ELSE TOKEN_LR TOKEN_RR TOKEN_LP TOKEN_RP TOKEN_COMMA TOKEN_COMMENTS TOKEN_MULTI_COMMENTS TOKEN_HASHBANG_COMMENT TOKEN_PRINT TOKEN_SOME_OPERATOR TOKEN_OPERATOR TOKEN_SPACE TOKEN_PRIVATE_IDENTIFIER TOKEN_UNARY_OPERATOR TOKEN_DOT TOKEN_ANDOR TOKEN_FUNCTION TOKEN_RETURN TOKEN_IN TOKEN_NEW TOKEN_ARROW  TOKEN_NEWLINE TOKEN_EOF TOKEN_BREAK TOKEN_SWITCH TOKEN_CASE TOKEN_DEFAULT
%token TOKEN_INTEGER TOKEN_DECIMAL TOKEN_BINARY TOKEN_OCTAL TOKEN_EXP TOKEN_HEXADECIMAL TOKEN_BIG_INTEGER TOKEN_STRING TOKEN_BOOLEAN TOKEN_IDENTIFIER TOKEN_RE_ASSIGNMENT TOKEN_3DOTS TOKEN_NEGATION TOKEN_PLUS TOKEN_MINUS
%right TOKEN_COLON
%left TOKEN_QUESTION_MARK
%token TOKEN_COMP_OPERATOR

/* Rule Section */
%% 

input: ST
     | error { yyerror("Invalid Input: Syntax error"); } 

//Start
ST: NEWLINE TOKEN_HASHBANG_COMMENT P END_SMCLN TOKEN_EOF| NEWLINE P END_SMCLN;
P:  | A  END_SMCLN P;
A:  | ASS| PRINTSTMT| UNSTMT| DOWHILELP| WHILELP| COMMENTS | FUND | FUNC | FOR | TOKEN_LC P TOKEN_RC| ARRAY| METHOD| COMPEXP| IF_ELSE| RETURN | SWITCH;
END_SMCLN: |TOKEN_SMCLN
END_COMMA: |TOKEN_COMMA
NEWLINE: | NEWLINE TOKEN_NEWLINE;

/* if else */
IF_ELSE: TOKEN_IF TOKEN_LP COMPEXP TOKEN_RP IFSTMT IF_OPTIONS;
IF_OPTIONS: | ELSE_IF_BLOCK | ELSE_BLOCK | ELSE_IF_BLOCK  ELSE_BLOCK;
IFSTMT: TOKEN_SMCLN| F TOKEN_SMCLN | TOKEN_LC P3 TOKEN_RC | A ;
ELSE_IF_BLOCK: TOKEN_ELSE TOKEN_IF TOKEN_LP COMPEXP TOKEN_RP IFSTMT ;
ELSE_BLOCK:  TOKEN_ELSE TOKEN_SMCLN| TOKEN_ELSE F TOKEN_SMCLN | TOKEN_ELSE TOKEN_LC P3 TOKEN_RC | TOKEN_ELSE A;

//SWITCH
SWITCH: TOKEN_SWITCH TOKEN_LP COMPEXP TOKEN_RP TOKEN_LC SWITCH_IN TOKEN_RC;
SWITCH_IN: CASES DEFAULT ;
CASES: | TOKEN_CASE F TOKEN_COLON SWITCH_STMTS CASES;
DEFAULT: | TOKEN_DEFAULT TOKEN_COLON SWITCH_STMTS;
SWITCH_STMTS: | FUNCTION_BLOCK CASES| P3;

//Assignment 
ASS: F|TOKEN_VARIABLE TOKEN_IDENTIFIER TOKEN_EQUAL X ASSIGNMENT_COMMA2| TOKEN_LET TOKEN_IDENTIFIER TOKEN_EQUAL X ASSIGNMENT_COMMA2| TOKEN_CONST TOKEN_IDENTIFIER TOKEN_EQUAL X ASSIGNMENT_COMMA2 | UNINITIALIZED | WITHOUT_VAR_LET_CONST| 
X:  MULTI_EQUAL|  METHOD| FUNC| TOKEN_NEW FUNC| TOKEN_LP TOKEN_RP X_2; 
UNINITIALIZED: TOKEN_LET TOKEN_IDENTIFIER ASSIGNMENT_COMMA2| TOKEN_VARIABLE TOKEN_IDENTIFIER ASSIGNMENT_COMMA2;

WITHOUT_VAR_LET_CONST: TOKENID TOKEN_EQUAL MULTI_EQUAL2 ASSIGNMENT_COMMA1|TOKENID TOKEN_RE_ASSIGNMENT MULTI_EQUAL2 ASSIGNMENT_COMMA1| TOKENID ASSIGNMENT_COMMA1; // a=1,b,A?B:C expressions of this form. might not be stict identifiers.
ASSIGNMENT_COMMA1: | TOKEN_COMMA WITHOUT_VAR_LET_CONST; 

WITH_VAR_LET_CONST: TOKEN_IDENTIFIER TOKEN_EQUAL MULTI_EQUAL ASSIGNMENT_COMMA2|TOKEN_IDENTIFIER TOKEN_RE_ASSIGNMENT MULTI_EQUAL ASSIGNMENT_COMMA2| TOKEN_IDENTIFIER ASSIGNMENT_COMMA2; //strictly identifiers in assignment statements with comma
ASSIGNMENT_COMMA2: | TOKEN_COMMA WITH_VAR_LET_CONST 

MULTI_EQUAL: TOKEN_IDENTIFIER TOKEN_EQUAL MULTI_EQUAL|METHOD | FUNC| TOKEN_NEW FUNC|  TOKEN_IDENTIFIER OBJECT_PROPS| F;
MULTI_EQUAL2: MULTI_EQUAL | TOKENID TOKEN_EQUAL MULTI_EQUAL2

//Expressions
F:  TOKEN_NOT F| UNSTMT| TOKEN_NEGATION F |  FUNC| F TOKEN_BIN_OPERATOR F| F TOKEN_PLUS F|F TOKEN_MINUS F| F TOKEN_ANDOR F | D| F_TERNARY_RIGHT|  TOKEN_LP F EXPRESSION_COMMA TOKEN_RP X_2| F TOKEN_COMP_OPERATOR COMPEXP| ANONYMOUS_FUNCTION;
F_TERNARY_RIGHT: F TOKEN_QUESTION_MARK F TOKEN_COLON F // on right side of equality ternary expression on either side of colons can be variables or constants.
D: TOKEN_MINUS D| TOKEN_PLUS D| TOKEN_INTEGER |TOKEN_DECIMAL|TOKEN_BINARY|TOKEN_OCTAL|TOKEN_EXP|TOKEN_HEXADECIMAL|TOKEN_BIG_INTEGER|TOKEN_STRING|TOKEN_BOOLEAN| TOKENID | ARRAY| TOKEN_LP D EXPRESSION_COMMA TOKEN_RP X_2;
TOKENID_FLEXIBLE: TOKENID | FUNC;
TOKENID: TOKEN_IDENTIFIER | TOKEN_IDENTIFIER OBJECT_PROPS| F_TERNARY_LEFT| ARRAY_ELEMENT| OBJECT| TOKEN_LP TOKEN_IDENTIFIER EXPRESSION_COMMA TOKEN_RP X_2;
X_2: | TOKEN_ARROW FUNCTION_BLOCK;
F_TERNARY_LEFT: F TOKEN_QUESTION_MARK TOKENID TOKEN_COLON TOKENID;  // on left side of equality ternary expression on either side of colons cannot be constants.

//OBJECTS PROPERTIES CAN REPEAT ENDLESSLY
OBJECT_PROPS: TOKEN_DOT TOKEN_IDENTIFIER OBJECT_PROPS | TOKEN_DOT TOKEN_IDENTIFIER; 

//ANONYMOUS_FUNCTION I.E FUNCTION AS PARAMETERS
ANONYMOUS_FUNCTION: TOKEN_FUNCTION TOKEN_LP PARAM TOKEN_RP FUNCTION_BLOCK

EXPRESSION_COMMA: | TOKEN_COMMA F EXPRESSION_COMMA| TOKEN_COMMA WITHOUT_VAR_LET_CONST EXPRESSION_COMMA; // (x,y,z, and so on): takes the last one in this pattern after comma

//Function Definition
FUND: TOKEN_FUNCTION FUNCTION_DEFINITION;
FUNCTION_DEFINITION: TOKEN_IDENTIFIER TOKEN_LP PARAM TOKEN_RP FUNCTION_BLOCK;
FUNCTION_BLOCK: TOKEN_LC P3 TOKEN_RC;
PARAM: | TOKEN_IDENTIFIER PARAM2 ;
PARAM2: | TOKEN_COMMA TOKEN_IDENTIFIER PARAM2;
RETURN: |  TOKEN_RETURN F |   TOKEN_RETURN F TOKEN_SMCLN |  TOKEN_RETURN|  TOKEN_RETURN TOKEN_SMCLN;

//Function call
FUNC: TOKEN_IDENTIFIER TOKEN_LP PARAM3 TOKEN_RP; | TOKEN_IDENTIFIER OBJECT_PROPS TOKEN_LP PARAM3 TOKEN_RP
PARAM3: | F PARAM4 | TOKENID_FLEXIBLE PARAM4;
PARAM4: | TOKEN_COMMA F PARAM4| TOKEN_COMMA TOKENID_FLEXIBLE PARAM4;

//Method
METHOD: TOKEN_LC FUNCTION_DEFINITION END_COMMA TOKEN_RC    // Method means: const a={ m(x,y){return x*y}}  semicolon may or may not be there;

//Array 
ARRAY_ELEMENT: TOKEN_IDENTIFIER TOKEN_LR F TOKEN_RR 
ARRAY:  TOKEN_LR ARRAY_IN TOKEN_RR 
ARRAY_IN: | F | F TOKEN_COMMA ARRAY_IN; 

//Object
OBJECT: TOKEN_LC OBJECT_IN TOKEN_RC;
OBJECT_IN: | TOKEN_IDENTIFIER TOKEN_COLON F PROPERTIES_REPEAT;
PROPERTIES_REPEAT: END_COMMA | TOKEN_COMMA OBJECT_IN;

//print statement
PRINTSTMT: TOKEN_PRINT TOKEN_LP Z TOKEN_RP;
Z: F TOKEN_COMMA Z| F;

//Comments
COMMENTS: TOKEN_COMMENTS | TOKEN_MULTI_COMMENTS 

/*Unary statements*/
UNSTMT: TOKENID TOKEN_UNARY_OPERATOR|TOKEN_UNARY_OPERATOR TOKENID ;

/*for loop*/
FOR: TOKEN_FOR TOKEN_LP FOR_IN TOKEN_SMCLN FOR_COMPEXP TOKEN_SMCLN FOR_STMT TOKEN_RP TOKEN_LC P3 TOKEN_RC | TOKEN_FOR TOKEN_LP FOR_IN TOKEN_SMCLN FOR_COMPEXP TOKEN_SMCLN FOR_STMT TOKEN_RP F TOKEN_SMCLN| TOKEN_FOR TOKEN_LP FOR_IN_ID TOKEN_IN FOR_IN_ID TOKEN_RP TOKEN_LC P3 TOKEN_RC| TOKEN_FOR TOKEN_LP FOR_IN_ID TOKEN_IN FOR_IN_ID TOKEN_RP F TOKEN_SMCLN;
FOR_IN_ID: TOKEN_IDENTIFIER| TOKEN_IDENTIFIER OBJECT_PROPS| UNINITIALIZED| TOKEN_CONST TOKEN_IDENTIFIER;  // const a in x inside a for loop
FOR_COMPEXP: | COMPEXP | COMPEXP FOR_COMPEXP2;
FOR_COMPEXP2: | TOKEN_COMMA COMPEXP FOR_COMPEXP2;
FOR_IN: | ASS| ASS FOR_IN2;
FOR_IN2: | TOKEN_COMMA ASS FOR_IN2;
FOR_STMT: | WITHOUT_VAR_LET_CONST | F| WITHOUT_VAR_LET_CONST FOR_STMT2| F FOR_STMT2;
FOR_STMT2: | TOKEN_COMMA F FOR_STMT2;| TOKEN_COMMA WITHOUT_VAR_LET_CONST FOR_STMT2;


/*while loop*/
WHILELP: TOKEN_WHILE TOKEN_LP COMPEXP TOKEN_RP TOKEN_LC P3 TOKEN_RC| TOKEN_WHILE TOKEN_LP COMPEXP TOKEN_RP F TOKEN_SMCLN;


/*do while loop*/
DOWHILELP: TOKEN_DO TOKEN_LC P3 TOKEN_RC TOKEN_WHILE TOKEN_LP COMPEXP TOKEN_RP TOKEN_SMCLN| TOKEN_DO F TOKEN_SMCLN TOKEN_WHILE TOKEN_LP COMPEXP TOKEN_RP TOKEN_SMCLN;

/*conditional statement*/
COMPEXP: F TOKEN_COMP_OPERATOR COMPEXP| F| TOKEN_LC COMPEXP TOKEN_RC;

//LOOP BLOCKS MUST ALLOW BREAK STATEMENT;
P3:  | A3  END_SWITCH P3 END_SWITCH| A3;  
A3:  | ASS| PRINTSTMT| UNSTMT| DOWHILELP| WHILELP| COMMENTS | FUND | FUNC | FOR | TOKEN_LC P TOKEN_RC| ARRAY| METHOD| COMPEXP| IF_ELSE| RETURN | SWITCH| TOKEN_BREAK;
END_SWITCH: | TOKEN_SMCLN;
%% 

void yyerror(const char *msg) {
    fprintf(stderr, "%s after '%s'\n", msg, yytext);
    flag = 1;
    exit(1);
}